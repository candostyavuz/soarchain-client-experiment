"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpBatchClient = exports.defaultHttpBatchClientOptions = void 0;
const json_rpc_1 = require("@cosmjs/json-rpc");
const httpclient_1 = require("./httpclient");
const rpcclient_1 = require("./rpcclient");
exports.defaultHttpBatchClientOptions = {
    dispatchInterval: 20,
    batchSizeLimit: 20,
};
class HttpBatchClient {
    constructor(endpoint, options = exports.defaultHttpBatchClientOptions) {
        this.queue = [];
        this.options = options;
        if (typeof endpoint === "string") {
            // accept host.name:port and assume http protocol
            this.url = (0, rpcclient_1.hasProtocol)(endpoint) ? endpoint : "http://" + endpoint;
        }
        else {
            this.url = endpoint.url;
            this.headers = endpoint.headers;
        }
        this.timer = setInterval(() => this.tick(), options.dispatchInterval);
        this.validate();
    }
    disconnect() {
        this.timer && clearInterval(this.timer);
        this.timer = undefined;
    }
    async execute(request) {
        return new Promise((resolve, reject) => {
            this.queue.push({ request, resolve, reject });
        });
    }
    validate() {
        if (!this.options.batchSizeLimit ||
            !Number.isSafeInteger(this.options.batchSizeLimit) ||
            this.options.batchSizeLimit < 1) {
            throw new Error("batchSizeLimit must be a safe integer >= 1");
        }
    }
    async tick() {
        // Avoid race conditions
        const queue = this.queue.splice(0, this.options.batchSizeLimit);
        if (!queue.length)
            return;
        const request = queue.map((s) => s.request);
        const raw = await (0, httpclient_1.http)("POST", this.url, this.headers, request);
        // Requests with a single entry return as an object
        const arr = Array.isArray(raw) ? raw : [raw];
        arr.forEach((el) => {
            const req = queue.find((s) => s.request.id === el.id);
            if (!req)
                return;
            const { reject, resolve } = req;
            const response = (0, json_rpc_1.parseJsonRpcResponse)(el);
            if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
                reject(new Error(JSON.stringify(response.error)));
            }
            else {
                resolve(response);
            }
        });
    }
}
exports.HttpBatchClient = HttpBatchClient;
//# sourceMappingURL=httpbatchclient.js.map